// *********************************************************
//
// File autogenerated for the ${pkgname} package
// by the rosinterface_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <stdlib.h>
#include <string>
#include <limits>
#include <memory>
#include <ros/param.h>
#include <ros/node_handle.h>
#include <rosinterface_handler/utilities.hpp>
#ifdef MESSAGE_FILTERS_FOUND
#include <message_filters/subscriber.h>
$includes
#else
$includeError
#endif
#ifdef DYNAMIC_RECONFIGURE_FOUND
#include <${pkgname}/${ClassName}Config.h>
#include <functional>
#else
struct ${ClassName}Config{};
#endif


namespace ${pkgname} {

/// \brief Parameter struct generated by rosinterface_handler
struct ${ClassName}Interface {

  using Config = ${ClassName}Config;
#ifdef MESSAGE_FILTERS_FOUND
  template<typename T>
  using SubscriberPtr = std::shared_ptr<message_filters::Subscriber<T>>;
#endif

  ${ClassName}Interface(const ros::NodeHandle& private_node_handle)
  :$initSubscribers globalNamespace{"/"},
    publicNamespace{rosinterface_handler::getParentNamespace(private_node_handle) + "/"},
    privateNamespace{private_node_handle.getNamespace() + "/"},
    nodeName{rosinterface_handler::getNodeName(private_node_handle)},
    privateNodeHandle{private_node_handle} {
#ifdef DYNAMIC_RECONFIGURE_FOUND
    reconfigureServer.setCallback(boost::bind(& ${ClassName}Interface::fromConfig, this, _1, _2));
#endif
    }

  /// \brief Get values from parameter server
  /// 
  /// Will fail if a value can not be found and no default value is given.
  void fromParamServer(){
    bool success = true;
$fromParamServer

$subscribeAdvertiseFromParamServer

$test_limits
    if(!success){
      missingParamsWarning();
      rosinterface_handler::exit("RosinterfaceHandler: GetParam could net retrieve parameter.");
    }
    ROS_DEBUG_STREAM(*this);
  }

  /// \brief Set parameters on ROS parameter server.
  void toParamServer(){
$toParamServer        
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void fromConfig(const Config& config, const uint32_t level = 0){
#ifdef DYNAMIC_RECONFIGURE_FOUND
$subscribeAdvertiseFromConfig
$fromConfig
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
  rosinterface_handler::exit("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  void setReconfigureCallback(std::function<void(const Config&, const uint32_t)> func) {
    reconfigureServer.setCallback(func);
  }

  /// \brief Stream operator for printing parameter struct
  friend std::ostream& operator<<(std::ostream& os, const ${ClassName}Interface& p)
  {
    os << "[" << p.nodeName << "]\nNode " << p.nodeName << " has the following parameters:\n"
$string_representation;
    return os;
  }

  $parameters
  $publishers
  $subscribers

private:
  /// \brief Issue a warning about missing default parameters.
  void missingParamsWarning(){
    ROS_WARN_STREAM("[" << nodeName << "]\nThe following parameters do not have default values and need to be specified:\n"
$non_default_params    );
  }

  const std::string globalNamespace;
  const std::string publicNamespace;
  const std::string privateNamespace;
  const std::string nodeName;
  ros::NodeHandle privateNodeHandle;
#ifdef DYNAMIC_RECONFIGURE_FOUND
  dynamic_reconfigure::Server<Config> reconfigureServer;
#endif

};

} // namespace ${pkgname}
