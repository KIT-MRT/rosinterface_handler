// *********************************************************
//
// File autogenerated for the ${pkgname} package
// by the rosparam_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <stdlib.h>
#include <string>
#include <limits>
#include <ros/param.h>
#include <ros/node_handle.h>
#include <rosparam_handler/utilities.hpp>
#ifdef DYNAMIC_RECONFIGURE_FOUND
#include <${pkgname}/${ClassName}Config.h>
#else
struct ${ClassName}Config{};
#endif


namespace ${pkgname} {

struct ${ClassName}Parameters {

  using Config = ${ClassName}Config;

  ${ClassName}Parameters(const ros::NodeHandle& private_node_handle)
  : privateNamespace{private_node_handle.getNamespace() + "/"},
    nodeName{rosparam_handler::getNodeName(private_node_handle)},
    globalNamespace{"/"} {}

  void fromParamServer(){
$fromParamServer

$test_limits
  ROS_DEBUG_STREAM(*this);
  }

  void fromConfig(const Config& config, const uint32_t level = 0){
#ifdef DYNAMIC_RECONFIGURE_FOUND
$fromConfig
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
  rosparam_handler::exit("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  friend std::ostream& operator<<(std::ostream& os, const ${ClassName}Parameters& p)
  {
    os << "[" << p.nodeName << "]\nNode " << p.nodeName << " has the following parameters:\n"
$string_representation;
    return os;
  }

  void missingParamsWarning(){
    ROS_WARN_STREAM("[" << nodeName << "]\nThe following parameters do not have default values and need to be specified:\n"
$non_default_params    );
  }

  template <typename T>
  void getParam(const std::string key, T& val) {
    if (!ros::param::has(key)) {
      ROS_ERROR_STREAM("Parameter '" << key << "' is not defined.");
      missingParamsWarning();
      rosparam_handler::exit("RosparamHandler: Undefined parameter.");
    } else if (!ros::param::get(key, val)) {
      ROS_ERROR_STREAM("Could not retrieve parameter'" << key << "'. Does it have a different type?");
      missingParamsWarning();
      rosparam_handler::exit("RosparamHandler: GetParam could net retrieve parameter.");
    }
  }

  template <typename T>
  void getParam(const std::string key, T& val, const T& defaultValue) {
    if (!ros::param::has(key)) {
        val = defaultValue;
    } else if (!ros::param::get(key, val)) {
        ROS_WARN_STREAM("Parameter "<<key<<" is set, but has a different type. Using default value instead.");
        val = defaultValue;
	}
  }

  void testConstParam(const std::string key){
    if (ros::param::has(key)) {
      ROS_WARN_STREAM("Parameter " << key << "' was set on the parameter server eventhough it was defined to be constant.");
    }
  }

  template<typename T>
  typename std::enable_if<std::is_arithmetic<T>::value, void>::type
  testMin(const std::string key, T& val, T min = std::numeric_limits<T>::min()){
    if (val < min){
      ROS_WARN_STREAM("Value of " << val << " for "
                      << key << " is smaller than minimal allowed value. Correcting value to min=" << min);
      val = min;
    }
  }

  template<typename T>
  typename std::enable_if<is_vector<T>::value && std::is_arithmetic<typename T::value_type>::value, void>::type
  testMin(const std::string key, T& val, typename T::value_type min = std::numeric_limits<typename T::value_type>::min()){
    for (auto& v : val) testMin(key, v, min);
  }

  template<typename T>
  typename std::enable_if<is_map<T>::value && std::is_arithmetic<typename T::mapped_type>::value, void>::type
  testMin(const std::string key, T& val, typename T::mapped_type min = std::numeric_limits<typename T::mapped_type>::min()){
    for (auto& v : val) testMin(key, v.second, min);
  }

  template<typename T>
  typename std::enable_if<std::is_arithmetic<T>::value, void>::type
  testMax(const std::string key, T& val, T max = std::numeric_limits<T>::max()){
    if (val > max){
      ROS_WARN_STREAM("Value of " << val << " for "
                      << key << " is greater than maximal allowed. Correcting value to max=" << max);
      val = max;
    }
  }

  template<typename T>
  typename std::enable_if<is_vector<T>::value && std::is_arithmetic<typename T::value_type>::value, void>::type
  testMax(const std::string key, T& val, typename T::value_type min = std::numeric_limits<typename T::value_type>::max()){
    for (auto& v : val) testMax(key, v, min);
  }

  template<typename T>
  typename std::enable_if<is_map<T>::value && std::is_arithmetic<typename T::mapped_type>::value, void>::type
  testMax(const std::string key, T& val, typename T::mapped_type min = std::numeric_limits<typename T::mapped_type>::max()){
    for (auto& v : val) testMax(key, v.second, min);
  }

  $parameters

  private:
    const std::string globalNamespace;
    const std::string privateNamespace;
    const std::string nodeName;
};

} // namespace ${pkgname}
